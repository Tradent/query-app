// This is a mock service that would be replaced with actual ML/AI-based image similarity in production
// In a real implementation, this would use computer vision APIs, embeddings, or ML models

import type { ImageResult } from "@/types/search-types"

// Mock database of image embeddings (vector representations)
// In a real system, these would be generated by ML models
const mockImageEmbeddings: Record<string, number[]> = {
  img1: [0.2, 0.5, 0.8, 0.1, 0.9],
  img2: [0.3, 0.6, 0.7, 0.2, 0.8],
  img3: [0.1, 0.4, 0.9, 0.3, 0.7],
  img4: [0.4, 0.7, 0.6, 0.1, 0.5],
  img5: [0.5, 0.8, 0.3, 0.2, 0.6],
  img6: [0.2, 0.5, 0.8, 0.1, 0.9], // Similar to img1
  img7: [0.3, 0.5, 0.8, 0.15, 0.85], // Similar to img1
  img8: [0.25, 0.55, 0.75, 0.12, 0.88], // Similar to img1
  img9: [0.35, 0.65, 0.75, 0.25, 0.85], // Similar to img2
  img10: [0.28, 0.58, 0.72, 0.18, 0.82], // Similar to img2
  img11: [0.15, 0.45, 0.85, 0.35, 0.75], // Similar to img3
  img12: [0.12, 0.42, 0.88, 0.32, 0.72], // Similar to img3
  img13: [0.38, 0.68, 0.62, 0.15, 0.55], // Similar to img4
  img14: [0.42, 0.72, 0.58, 0.12, 0.52], // Similar to img4
  img15: [0.48, 0.78, 0.35, 0.25, 0.65], // Similar to img5
  img16: [0.52, 0.82, 0.32, 0.22, 0.62], // Similar to img5
  img17: [0.22, 0.52, 0.78, 0.12, 0.92], // Similar to img1
  img18: [0.32, 0.62, 0.68, 0.22, 0.78], // Similar to img2
  img19: [0.08, 0.38, 0.92, 0.28, 0.68], // Similar to img3
  img20: [0.45, 0.75, 0.55, 0.15, 0.58], // Similar to img4
}

// Calculate cosine similarity between two vectors
function cosineSimilarity(vecA: number[], vecB: number[]): number {
  if (vecA.length !== vecB.length) {
    throw new Error("Vectors must have the same length")
  }

  let dotProduct = 0
  let normA = 0
  let normB = 0

  for (let i = 0; i < vecA.length; i++) {
    dotProduct += vecA[i] * vecB[i]
    normA += vecA[i] * vecA[i]
    normB += vecB[i] * vecB[i]
  }

  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB))
}

// Find visually similar images
export async function findSimilarImages(imageId: string, allImages: ImageResult[], limit = 8): Promise<ImageResult[]> {
  // In a real implementation, this would query a vector database or ML service
  // For now, we'll use our mock embeddings and cosine similarity

  // Get the embedding for the target image
  const targetEmbedding = mockImageEmbeddings[imageId]
  if (!targetEmbedding) {
    return []
  }

  // Calculate similarity scores for all images
  const similarities = Object.entries(mockImageEmbeddings)
    .filter(([id]) => id !== imageId) // Exclude the target image
    .map(([id, embedding]) => ({
      id,
      similarity: cosineSimilarity(targetEmbedding, embedding),
    }))
    .sort((a, b) => b.similarity - a.similarity) // Sort by similarity (descending)
    .slice(0, limit) // Take top N results

  // Map similarity results to actual image objects
  const similarImages = similarities
    .map((sim) => allImages.find((img) => img.id === sim.id))
    .filter((img): img is ImageResult => img !== undefined)

  // Simulate network delay
  await new Promise((resolve) => setTimeout(resolve, 500))

  return similarImages
}

// Get image embedding (would be generated by ML model in real implementation)
export function getImageEmbedding(imageId: string): number[] | null {
  return mockImageEmbeddings[imageId] || null
}

// Generate embedding from image data (mock implementation)
export async function generateEmbeddingFromImage(imageData: File | string): Promise<number[]> {
  // In a real implementation, this would send the image to an ML service
  // For now, return a random embedding
  await new Promise((resolve) => setTimeout(resolve, 1000))

  return Array(5)
    .fill(0)
    .map(() => Math.random())
}
